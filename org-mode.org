#+TITLE: Org Mode - Organize Your Life In Plain Text!
#+LANGUAGE:  en
#+AUTHOR: Bernt Hansen
#+EMAIL: bernt@norang.ca
#+OPTIONS:   H:3 num:t   toc:2 \n:nil @:t ::t |:t ^:nil -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:nil skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+DESCRIPTION: A description of how I currently use org-mode
#+KEYWORDS:  org-mode Emacs organization GTD getting-things-done
#+SEQ_TODO: UNFINISHED COMPLETE
#+INFOJS_OPT: view:nil toc:t ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:   
#+LINK_HOME: 
* Overview
This is currently a work-in-progress.

Org-mode is a fabulous organizational tool built by Carsten Dominik
that operates on plain text files.  Org-mode is part of Emacs.

This document attempts to describe how I use org-mode in my day-to-day
work.  I have been using org-mode as my personal information manager
for years now.  I started small with just the default =TODO= and
=DONE= keywords and grew my use of org-mode to fit my workflow.

I still change my workflow and tweak little things regularly but right
now this document describes most of my current org-mode setup.

I'm assuming you've had some exposure to org-mode already so concepts
like the agenda, remember mode, etc.  won't be completely foreign to
you.  More information about org-mode can be found in the [[http://orgmode.org/index.html#sec-4.1][Org-Mode
Manual]] and on the [[http://orgmode.org/worg/][Worg Site]].

This document is created using the publishing features of org-mode.
The source for this document can be found at
http://doc.norang.ca/org-mode.org.html and
http://doc.norang.ca/org-mode.org
* Getting Started
  I use =org-mode= in most of my emacs buffers.
** Org-Mode Setup
The following setup in my .emacs enables org-mode for most buffers.
=org-mode= is the default mode for =.org=, =.org_archive=, and =.txt=
files.

#+begin_src emacs-lisp
;;;
;;; Org Mode
;;;
(add-to-list 'load-path (expand-file-name "~/git/org-mode/lisp"))
(add-to-list 'auto-mode-alist '("\\.\\(org\\|org_archive\\|txt\\)$" . org-mode))
(require 'org-install)
;;
;; Standard key bindings
(global-set-key "\C-cl" 'org-store-link)
(global-set-key "\C-ca" 'org-agenda)
(global-set-key "\C-cb" 'org-iswitchb)
#+end_src

=orgstruct++-mode= is enabled in =Gnus= message buffers to aid in
creating structured email messages.

#+begin_src emacs-lisp
(setq message-mode-hook
      (quote (orgstruct++-mode
	      (lambda nil (setq fill-column 72) (flyspell-mode 1))
	      turn-on-auto-fill
	      bbdb-define-all-aliases)))
#+end_src

=flyspell-mode= is enabled for almost everything to help prevent
creating documents with spelling errors.  =yasnippets= are enabled to
speed up creation of standard text blocks in most editing modes.

#+begin_src emacs-lisp
;; Make TAB the yas trigger key in the org-mode-hook and turn on flyspell mode
(add-hook 'org-mode-hook
	  (lambda ()
	    ;; yasnippet
	    (make-variable-buffer-local 'yas/trigger-key)
	    (setq yas/trigger-key [tab])
	    (define-key yas/keymap [tab] 'yas/next-field-group)
	    ;; flyspell mode to spell checking everywhere
	    (flyspell-mode 1)))
#+end_src

** Organizing Your Life Into Org Files
   Tasks are separated into logical groupings or projects.  
   Use separate org files for large task groupings.

   Here are sample files that I use.

   The following org files collect non-work related tasks:

   | Filename     | Description                                |
   |--------------+--------------------------------------------|
   | todo.org     | Personal tasks and things to keep track of |
   | gsoc2009.org | Google Summer of Code stuff for 2009       |
   | farm.org     | Farm related tasks                         |
   | mark.org     | Tasks related to my son Mark               |
   | org.org      | Org-mode related tasks                     |
   | git.org      | Git related tasks                          |
   | bzflag.org   | BZFlag related tasks                       | 

   The following org-files are the targets for remember notes:

   | Filename  | Description            |
   |-----------+------------------------|
   | tasks.org | New task bucket        |
   | notes.org | New notes bucket       |
   | phone.org | New phone calls bucket |

   The following work-related org-files keep my business notes (using
   fictitious client names)

   | Filename    | Description                             |
   |-------------+-----------------------------------------|
   | norang.org  | Norang tasks and notes                  |
   | XYZ.org     | XYZ Corp tasks and notes                |
   | ABC.org     | ABC Ltd tasks                           |
   | ABC-DEF.org | ABC Ltd tasks for their client DEF Corp |
   | ABC-KKK.org | ABC Ltd tasks for their client KKK Inc  |
   | YYY.org     | YYY Inc tasks                           |

   Org-mode is great for dealing with multiple clients and client
   projects.  An org file becomes the collection of projects, notes,
   etc. for a single client or client-project.

   Clients (ABC Ltd) has multiple customer systems that I work on.
   Separating the tasks for each client-customer into separate org
   files helps keep things logically grouped and since clients come
   and go this allows entire org files to be added or dropped from my
   agenda to keep only what is important visible in agenda views.

   Other org files are used for publishing only and do not contribute to the agenda.
   See [[Publishing]] for more details.

** Agenda Setup
   Here is my current =org-agenda-files= setup.  It is shown above
   formatted as a =setq= for clarity but in reality this is saved in
   my custom.el file.
#+begin_src emacs-lisp
(setq org-agenda-files (quote ("~/git/org/tasks.org"
			       "~/git/org/gsoc2009.org"
			       "~/git/org/farm.org" 
			       "~/git/org/mark.org"
			       "~/git/org/notes.org"
			       "~/git/org/phone.org"
			       "~/git/org/org.org"
			       "~/git/org/norang.org"
			       ; client org files removed
			       "~/git/org/git.org"
			       "~/git/org/todo.org"
			       "~/git/org/bzflag.org")))
#+end_src

   =org-mode= manages the =org-agenda-files= variable.  I just visit
   an org file and add it to the agenda with =C-c [=.  To remove a
   file I just visit it and hit =C-c ]= and all of the tasks in that
   file are instantly removed from my agenda views until I add them
   back again.
** Org file structure
   Most of my org files are set up with level 1 headings as main
   categories only.  Tasks and projects normally start as level 2
   tasks but I have a few level 1 =PROJECT= tasks.

   Here are some examples of my level 1 headings in

   =todo.org=:

   - Appointments
   - Special Dates

     Includes level 2 headings for

     - Birthdays
     - Anniversaries
     - Holidays
   - Finances
   - Health
   - House Maintenance
   - Medical
   - Miscellaneous
   - Lawn and Garden

   =norang.org=:

   - System Maintenance
   - Payroll
   - Accounting
   - Finances
   - Hardware Maintenance
   - Quotes
   - Administration
   - Research

   Each of these level 1 tasks normally has a =property drawer=
   specifying the archive location and category for any tasks in that
   tree.  Level 1 headings are set up like this:

: ** Appointments
:    :PROPERTIES:
:    :CATEGORY: Appt
:    :ARCHIVE:  %s_archive::* Appointments
:    :END:      
:    ...
: ** Miscellaneous
:    :PROPERTIES:
:      :CATEGORY: todo
:      :ARCHIVE: %s_archive::* Miscellaneous
:    :END:

   This ensures that any level 2 task that I archive from this heading
   (I archive by subtree) gets saved in the archive file under the
   appropriate level 1 heading so I can find it back again if needed.

   This keeps my main org files and my archives with basically the
   same structure.

** Key bindings
   I live in the agenda.  To make getting to the agenda faster I
   mapped =F12= to the sequence =C-c a= since I'm using it hundreds of
   times a day.

   I have the following custom key bindings set up for my emacs (sorted by frequency).
#+end_example


| Key     | For                                             | Used       |
|---------+-------------------------------------------------+------------|
| F12     | Agenda (1 key less than C-c a)                  | Very Often |
| C-c b   | Switch to org file                              | Very Often |
| f9 g    | Gnus - I live in gnus                           | Often      |
| C-M-r   | Create a remember task                          | Often      |
| F11     | Goto currently clocked item                     | Often      |
| f5      | Show todo items for this subtree                | Often      |
| S-f5    | Widen                                           | Often      |
| f9 b    | Quick access to bbdb data                       | Often      |
| f9 c    | Calendar access                                 | Often      |
| f9 r    | Boxquote selected region                        | Often      |
| C-S-f12 | Save buffers and publish current project        | Often      |
| C-c l   | Store a link for retrieval with C-c C-l         | Often      |
| f8      | Go to next org file in org-agenda-files         | Sometimes  |
| f9 v    | Toggle visible mode (for showing/editing links) | Sometimes  |
| C-f9    | Previous buffer                                 | Sometimes  |
| C-f10   | Next buffer                                     | Sometimes  |
| C-x n r | Narrow to region                                | Sometimes  |
| f9 f    | Boxquote insert a file                          | Sometimes  |
| f9 i    | Org-mode Info manual                            | Sometimes  |
| f9 o    | Org occur search                                | Rare       |
| f7      | Toggle line truncation/wrap                     | Rare       |
| f9 u    | Untabify region                                 | Rare       |
| C-c a   | Enter Agenda (minimal emacs testing)            | Rare       |
   
   Here is the keybinding setup in lisp:
#+begin_src emacs-lisp
;; Custom Key Bindings
(global-set-key (kbd "<f12>") 'org-agenda)
(global-set-key (kbd "<f5>") 'my-org-todo)
(global-set-key (kbd "<S-f5>") 'widen)
(global-set-key (kbd "<f7>") 'set-truncate-lines)
(global-set-key (kbd "<f8>") 'org-cycle-agenda-files)
(global-set-key (kbd "<f9> b") 'bbdb)
(global-set-key (kbd "<f9> c") 'calendar)
(global-set-key (kbd "<f9> f") 'boxquote-insert-file)
(global-set-key (kbd "<f9> g") 'gnus)
(global-set-key (kbd "<f9> i") (lambda ()
				 (interactive)
				 (info "~/git/org-mode/doc/org.info")))
(global-set-key (kbd "<f9> o") 'org-occur)
(global-set-key (kbd "<f9> r") 'boxquote-region)
(global-set-key (kbd "<f9> u") (lambda ()
				 (interactive)
				 (untabify (point-min) (point-max))))
(global-set-key (kbd "<f9> v") 'visible-mode)
(global-set-key (kbd "C-<f9>") 'previous-buffer)
(global-set-key (kbd "C-x n r") 'narrow-to-region)
(global-set-key (kbd "C-<f10>") 'next-buffer)
(global-set-key (kbd "<f11>") 'org-clock-goto)
(global-set-key (kbd "C-s-<f12>") 'my-save-then-publish)
#+end_src

* Tasks and States
  I use one set of TODO keywords for all of my org files.  Org-mode
  lets you define TODO keywords per file but I find it's easier to
  have a standard set of TODO keywords globally so I can use the same
  setup in any org file I'm working with.

  The only exception to this is this document :) since I don't want
  =org-mode= hiding the =TODO= keyword when it appears in headlines.
  I've set up a dummy =#+SEQ_TODO: FIXME FIXED= entry at the top of
  this file just to leave my =TODO= keyword untouched in this
  document.
** ToDo keywords
Here are my =TODO= state keywords and colour settings:

#+begin_src emacs-lisp 
(setq org-todo-keywords (quote ((sequence "TODO(t)" "STARTED(s)" "|" "DONE(d!/!)")
 (sequence "WAITING(w@/!)" "SOMEDAY(S!)" "PROJECT(P@)" "OPEN(O@") "|" "CANCELLED(c@/!)")
 (sequence "QUOTE(q!)" "QUOTED(Q!)" "|" "APPROVED(A@)" "EXPIRED(E@)" "REJECTED(R@)"))))

(setq org-todo-keyword-faces (quote (("TODO" :foreground "red" :weight bold)
 ("STARTED" :foreground "blue" :weight bold)
 ("DONE" :foreground "forest green" :weight bold)
 ("WAITING" :foreground "orange" :weight bold)
 ("SOMEDAY" :foreground "magenta" :weight bold)
 ("CANCELLED" :foreground "forest green" :weight bold)
 ("QUOTE" :foreground "red" :weight bold)
 ("QUOTED" :foreground "magenta" :weight bold)
 ("APPROVED" :foreground "forest green" :weight bold)
 ("EXPIRED" :foreground "forest green" :weight bold)
 ("REJECTED" :foreground "forest green" :weight bold)
 ("OPEN" :foreground "blue" :weight bold)
 ("PROJECT" :foreground "red" :weight bold))))
#+end_src
*** Normal Task States
Normal tasks go through the sequence =TODO= -> =STARTED= -> =DONE=.
The second sequence is really just a convenient collection of odd-ball
states for tasks (=WAITING=, =SOMEDAY=, =CANCELLED=).

The following diagram shows the possible state transitions for a task.

#+begin_ditaa task_states.png -r -s 0.8
:       +--------+       +---------+       +--------+
:       |        |       |         |       |        |
:    +--+  TODO  +------>+ STARTED +------>+  DONE  |
:    |  | cRED   |       |  cBLU   |       | cGRE   |
:    |  +--+-+---+       +--+---+--+       +--------+
:    |     ^ ^              ^   |
:    |     | |              |   |
:    |     | :  +------=----+   +------=------+
:    |     : +--|----=-------+                |
:    |     |    |            |                |
:    |     v    v            v                v
:    |  +--+----+-+     +----+----+     +-----+-----+
:    |  |         |     |         |     |           |
:    |  | WAITING |     | SOMEDAY |     | CANCELLED |
:    |  |   cF60  |     |  cC0C   |     |   cGRE    |
:    |  +----+----+     +---+--+--+     +-----+--+--+
:    |       ^              ^  |              ^  ^
:    |       |              |  |              |  |
:    |       +--=-----------+  +-=------------+  |
:    |                                           |
:    +---=---------------------------------------+
: 
: 
:         -------- Normal state changes
:         ----=--- Optional state changes
#+end_ditaa

*** Quotation Task States
I also do fixed-price quotation work.  Quotations use the following state transitions:

#+begin_ditaa quote_states.png -r -s 0.8
:                                              +----------+
:                                              |          |
:                                          +-->+ EXPIRED  |
:                                          |   | cGRE     |
:                                          |   +----------+
:                                          |
:                                          |
:       +-------------+       +--------+   :   +----------+
:       |             |       |        +---+   |          |
:       |    QUOTE    +------>+ QUOTED +------>+ APPROVED |
:       | cRED        |       |  cC0C  +---+   | cGRE     |
:       +-------------+       +--+---+-+   :   +----------+
:                                          |
:                                          |
:                                          |   +----------+
:                                          |   |          |
:                                          +-->+ REJECTED |
:                                              | cGRE     |
:                                              +----------+
#+end_ditaa

*** Purchase Order Task States
Fixed price jobs normally have a =Purchase Order= associated with it which is used for billing the client.
The following states track purchase orders.

#+begin_ditaa po_states.png -r -s 0.8
:       +----------+       +---------+
:       |          |       |         |
:       |   OPEN   +------>+   DONE  |
:       | cRED     |       |  cGRE   |
:       +----------+       +---------+
#+end_ditaa

*** Project Task States
Finally I also track projects which are really super-tasks.  Projects normally have lots of individual tasks
that can be estimated and clocked.  Projects use the following state transitions:

#+begin_ditaa project_states.png -r -s 0.8
:                                 +---------------+
:                                 |               |
:                                 |      DONE     |
:                                 | cGRE          |
:                                 +----+----------+
:                                      ^      
:       +-------------+                |
:       |             +----------------+
:       |   PROJECT   |
:       | cRED        +-----------=----+
:       +-------------+                |
:                                      v            
:                                 +----+----------+
:                                 |               |
:                                 |   CANCELLED   |
:                                 | cGRE          |
:                                 +---------------+
#+end_ditaa

** Fast Todo Selection
   Fast todo selection allows changing from any task todo state to any
   other state directly by selecting the appropriate key from the fast
   todo selection key menu.  This is a great feature!

#+begin_src emacs-lisp 
(setq org-use-fast-todo-selection t)
#+end_src lisp

    Changing a task state is done with 
: C-c C-t KEY

    where =KEY= is the appropriate fast todo state selection key as defined in =org-todo-keywords=.
** ToDo state triggers
   I have a few triggers that automatically assign tags to tasks based
   on state changes.  If a task moves to =CANCELLED= state then it
   gets a =CANCELLED= tag.  Moving a =CANCELLED= task back to =TODO=
   removes the =CANCELLED= tag.  These are used for filtering tasks in
   agenda views which I'll talk about later.

   The triggers break down to the following rules:

   - Moving a task to =CANCELLED= adds a =CANCELLED= tag
   - Moving a task to =WAITING= adds a =WAITING= tag
   - Moving a task to =SOMEDAY= adds a =WAITING= tag
   - Moving a task to a done state removes =NEXT= and =WAITING= tags
   - Moving a task to =TODO= removes =WAITING= and =CANCELLED= tags
   - Moving a task to =STARTED= removes a =WAITING= tag
   - Moving a task to =PROJECT= removes a =CANCELLED= tag and adds a =PROJECT= tag

   The tags are used to filter tasks in the agenda views conveniently.

#+begin_src emacs-lisp 
(setq org-todo-state-tags-triggers
      (quote (("CANCELLED" ("CANCELLED" . t))
	      ("WAITING" ("WAITING" . t) ("NEXT"))
	      ("SOMEDAY" ("WAITING" . t))
	      (done ("NEXT") ("WAITING"))
	      ("TODO" ("WAITING") ("CANCELLED"))
	      ("STARTED" ("WAITING"))
	      ("PROJECT" ("CANCELLED") ("PROJECT" . t)))))
#+end_src

*** Using =STARTED= for clocked tasks
    Tasks automatically change to =STARTED= whenever they are clocked in.

#+begin_src emacs-lisp
;; Change task state to STARTED when clocking in
(setq org-clock-in-switch-to-state "STARTED")
#+end_src

* Adding New Tasks Quickly with Remember
  :PROPERTIES:
  :CUSTOM_ID: Remember
  :END:
  To add new tasks efficiently I use a minimal number of remember templates.
  I used to have lots of remember templates, one for each org-file.  I'd start org-remember with
  C-M-r and then pick a template that filed the task under =* Tasks= in the appropriate file.

  I found I still needed to refile these remember tasks again to the
  correct location within the org-file so all of these different
  remember templates weren't really helping at all.  Since then I've
  changed my workflow to use a minimal number of remember templates --
  I create the new task quickly and refile it once.  This also saves
  me from maintaining my org-remember templates when I add a new org file.
** Remember Templates
   When a new task needs to be added I categorize it into one of three
   things:

   - A phone call
   - A new task
   - A new note

   and pick the appropriate remember task.

   Here is my setup for org-remember

#+begin_src emacs-lisp
;;
;;;  Load Org Remember Stuff
(require 'remember)
(org-remember-insinuate)

;; Start clock if a remember buffer includes :CLOCK-IN:
(add-hook 'remember-mode-hook 'my-start-clock-if-needed 'append)

(defun my-start-clock-if-needed ()
  (save-excursion
    (goto-char (point-min))
    (when (re-search-forward " *:CLOCK-IN: *" nil t)
      (replace-match "")
      (org-clock-in))))

;; I use C-M-r to start org-remember
(global-set-key (kbd "C-M-r") 'org-remember)

;; Keep clocks running
(setq org-remember-clock-out-on-exit nil)

;; C-c C-c stores the note immediately
(setq org-remember-store-without-prompt t)

;; I don't use this -- but set it in case I forget to specify a location in a future template
(setq org-remember-default-headline "Tasks")

;; 3 remember templates for TODO tasks, Notes, and Phone calls
(setq org-remember-templates (quote (("todo" ?t "* TODO %?
  %u
  %a" "~/git/org/tasks.org" bottom nil)
				     ("note" ?n "* %?                                        :NOTE:
  %u
  %a" nil bottom nil)
				     ("phone" ?p "* PHONE %:name - %:company -                :PHONE:
  Contact Info: %a
  %u
  :CLOCK-IN:
  %?" "~/git/org/phone.org" bottom nil))))
#+end_src

   Each type of remember note goes in a separate org file with a =#+FILETAGS:= header which gives all tasks in that
   file a tag.
** Separate files for Remember Tasks
   I have 3 org files which are targets for my remember templates:

   | Remember File | Used for       |
   |---------------+----------------|
   | notes.org     | notes          |
   | tasks.org     | new TODO tasks |
   | phone.org     | phone calls    |

   Normally these files are empty except for a single line at the top which creates tags for anything in
   the files.  The three files look like this:

*** Notes.org - Remember file for notes
#+begin_example
#+FILETAGS: NOTES REFILE
#+end_example
*** Tasks.org - Remember file for TODO tasks
#+begin_example
#+FILETAGS: REFILE
#+end_example
*** Phone.org - Remember file for clocking phone calls
#+begin_example
#+FILETAGS: PHONE REFILE
#+end_example
** Remember Tasks is all about begin FAST
   Okay I'm in the middle of something and oh yeah - I have to remember to do that.
   I don't stop what I'm doing.  I'm probably clocking a project I'm working on and I don't want to
   lose my focus on that but I can't afford to forget this little thing that just came up.

   So what do I do?  Hit =C-M-r= to start remember mode and select =t= since it's a new task and I get a buffer like this
:  ##     C-c C-c  "~/git/org/tasks.org" -> "* bottom"
:  ## C-u C-c C-c  like C-c C-c, and immediately visit note at target location
:  ## C-0 C-c C-c  "???" -> "* ???"
:  ## C-1 C-c C-c  to select file and header location interactively.
:  ## C-2 C-c C-c  as child of the currently clocked item
:  ## To switch templates, use `C-M-r'.  To abort use `C-c C-k'.
: 
:  * TODO 
:    [2009-04-19 Sun]
:    [[file:~/git/doc.norang.ca/org-mode.org::*Remember%20Tasks%20is%20all%20about%20begin%20FAST][file:~/git/doc.norang.ca/org-mode.org::*Remember Tasks is all about begin FAST]]

   Enter the details of the TODO item and =C-c C-c= to file it away in tasks.org and go right back
   to what I'm really working on secure in the knowledge that that item isn't going to get lost and 
   I don't have to think about it anymore at all now.
* Refiling Tasks
  :PROPERTIES:
  :CUSTOM_ID: Refiling
  :END:
  Refiling tasks is easy.  After collecting a bunch of new tasks in my
  tasks.org file using remember mode I need to move these to the
  correct org file and topic.  All of my active org-files are in my
  =org-agenda-files= variable and contribute to the agenda.

  I collect tasks in my remember org files (tasks.org, phone.org,
  notes.org) for up to a week.  I do my weekly review every Monday and
  one of the tasks for that is to refile all remember tasks.  Often I
  end up refiling tasks the same day I create them because they show
  up in my daily clock report summary and are obviously in the wrong
  place.
** Refile Setup
   To refile tasks in org you need to tell it where you want to refile things.

   In my setup I let any file in =org-agenda-files= and the current file contribute to the list of valid refile targets.
   I don't refile to tasks more then 5 levels deep just to limit the number of displayed targets.
   I also use ido to help find targets quickly.

   Here is my refile configuration:
#+begin_src emacs-lisp
; Use IDO for target completion
(setq org-completion-use-ido t)

; Targets include this file and any file contributing to the agenda - up to 5 levels deep
(setq org-refile-targets (quote ((org-agenda-files :maxlevel . 5) (nil :maxlevel . 5))))

; Targets start with the file name - allows creating level 1 tasks
(setq org-refile-use-outline-path (quote file))

; Targets complete in steps so we start with filename, TAB shows the next level of targets etc 
(setq org-outline-path-complete-in-steps t)
#+end_src

   To refile a task to my =norang.org= file under =System Maintenance=
   I just put the cursor on the task and hit =C-c C-w= and enter =nor
   TAB sys TAB RET= and it's done.  I always know what file it's going
   into but if I don't remember the exact task name I can just hit TAB
   twice and all remember targets that match show up in a list.  Just
   scroll through the list and pick the right refile target.  This
   works great!
** Refiling Tasks
   To find tasks to refile I run my agenda view (=F12 r= = =C-c a r=)
   which shows tasks with the =REFILE= tag.  This view shows all tasks
   (even ones marked in a =done= state).

   All of my remember target files have this tag in the FILETAGS
   header so every task in the file can be found using this view.

   I visit each file with =REFILE= tasks to refile.  If there are a
   few files going to the same place (3 or less) I refile the first
   one, then move to the second one and use =C-c C-w up-arrow RET= to
   refile to the same location again.  If more than 3 tasks are going
   to the same place I try to do those last - since refiling
   everything else away helps to group those together.  Then I select
   the group of tasks and refile them in a single operation.

   Refiling all of my tasks tends to take less than a minute so I may
   do this a couple of times a day.
** Refiling Notes
   I keep a =* Notes*= headline in each of my org-mode files.
   These headlines have a =NOTES= tag which allows finding notes 
   across multiple files easily using the agenda search functions.

   Notes created by remember tasks go first to =notes.org= and are
   later refiled to the appropriate project file.  Some notes that are
   project related get filed to the appropriate project instead of the
   =NOTES= task.  Generally these types of note are specific to the
   project and not generally useful -- so removing them from the notes
   list when the project is archived makes sense.
** Refiling Phone Calls
   Phone calls are handled the same as notes.  I time my calls,
   creating them with =F12 p= and filing them in =phone.org=.  Later
   these are refiled to a =* Phone Calls= task which has a =PHONE= tag
   or to the project task that this clocked phone call should
   contribute clocked time to.  Some phone calls are billable and we
   want these tracked in the appropriate category.
* Custom agenda views
  I only have 5 custom agenda views defined.  Most of my old custom
  agenda views were rendered obsolete when filtering functionality was
  added to the agenda in newer versions of =org-mode=.

  Custom agenda views are used for
  - Finding =STARTED= tasks
  - Finding tasks to be refiled
  - Finding tasks waiting on something (=WAITING= or =SOMEDAY=)
  - Finding project tasks (=PROJECT=)
  - Finding notes

** Setup
#+begin_src emacs-lisp
(setq org-agenda-custom-commands 
      (quote (("P" "Projects" tags "/!PROJECT" ((org-use-tag-inheritance nil)))
	      ("s" "Started Tasks" todo "STARTED" ((org-agenda-todo-ignore-with-date nil)))
	      ("w" "Tasks waiting on something" tags "WAITING" ((org-use-tag-inheritance nil)))
	      ("r" "Refile New Notes and Tasks" tags "REFILE" ((org-agenda-todo-ignore-with-date nil)))
	      ("n" "Notes" tags "NOTES" nil))))
#+end_src

   My day goes generally like this:

   - Look at my agenda =F12 a=
     - make note of anything important to deal with today
   - Read email and news
     - create notes, and tasks for things that need responses with org-remember
   - Check refile tasks and respond to emails
   - Look at my agenda and knock off tasks scheduled for today
     - Clock it in since (=I= in the agenda while on the task -- this marks it as =STARTED=)
     - Work on it until it is =DONE= or it gets interrupted
   - Check today's time log report and refile tasks with clocked time
     - =F12 a R= - any tasks in =tasks.org= should be moved to the appropriate file
     - =F12 r= to get to refile tasks
     - =RET= on any task that needs to be refiled
     - repeat until the agenda timeclock report has all of the time in project files
     
** What do I work on next?
   Use the agenda view for =STARTED= tasks to find stuff in progress
   and things to clock.  I clock everything - some tasks are always in
   a =STARTED= state (Like Organization, Email News and IRC, etc)

   I use these tasks for clocking time while doing these activities
   and my list of =STARTED= tasks is normally less than 20 items long.

   When I look for a new task to work on I generally hit =F12 a= to
   get today's agenda and follow this order:

   - Pick something off today's agenda
     - deadline for today (do this first - it's not late yet)
     - deadline in the past (it's already late)
     - deadline that is coming up soon
     - a scheduled task for today (or in the past)
   - pick a STARTED task (it's unfinished)
   - If you run out of items to work on (yeah right) look for NEXT tasks to work on

*** Why keep it all on the =STARTED= list?
    I used to have a special keyword =ONGOING= for things that I do a
    lot and want to clock but never really start/end.  I had a special
    agenda view for =ONGOING= tasks that I would pull up to easily find
    the thing I want to clock.

    Since then I've moved away from using the =ONGOING= todo keyword
    and just use =STARTED= the same way.  If a task is clocked-in it
    automatically moves to the =STARTED= todo state and shows up on the
    list without having to think about it.  Having an agenda view that
    shows =STARTED= tasks makes it easy to pick the thing to clock -
    and I don't have to remember if I need to look in the =ONGOING=
    list or the =STARTED= list when looking for the task to clock-in.
    The =STARTED= list is basically 'what is current' - stuff I worked
    on recently and need to continue working on.  I want to find the
    thing to work on as fast as I can and actually do work on it - not
    spend time hunting through my org files for the task that needs to
    be clocked-in.

    I just find it easier to have it all in one short list.  My
    =STARTED= list has less than 20 entries so it's pretty easy to find
    what I want.  The whole point of the =STARTED= list is to make it
    quick and easy to find the task to clock-in.

    I only have 2 tasks that are permanently in a =STARTED= state.  These are:

      - Organization
      - Email, News, and IRC

    Everything else will eventually move to a =DONE= state and fall off
    the list.

    I found having two lists more confusing than just the single
    =STARTED= list.

** Reading email, newsgroups, and conversations on IRC
   To read email I do =F12 s C-s email RET I= which goes to the agenda
   view for started tasks, searches for 'email' and clocks it in.
   Then I go to Gnus and read everything in my inboxes.  If there are
   emails that require a response I use org-remember to create a new
   task with a heading of 'Respond to <user>' for each one.  This
   automatically links to the email in the task and makes it easy to
   find later.  Some emails are quick to respond to and some take
   research and a significant amount of time to complete.  I clock
   each one in it's own task just in case I need that clocked time
   later.

   Next, I go to my newly created tasks to be refiled with =F12 r= and
   clock in an email task and deal with it.  Repeat this until all of
   the 'Respond to <user>' tasks are marked =DONE=.

   I read email and newgroups in Gnus so I don't separate clocked time
   for quickly looking at things.  If an article has a useful piece of
   information I want to remember I create a note for it with =F12 n=
   and enter the topic and file it.  This takes practically no time at
   all and I know the note is safely filed for later.
** Filtering

   So many tasks, so little time.  I have hundreds of tasks at any
   give time (373 right now).  There is so much stuff to look at it
   can be daunting.  This is where agenda filtering saves the day.

   It's 11:53AM and I'm in work mode just before lunch.  I don't want
   to see tasks that are not work related right now.  I also don't
   want to work on a big project just before lunch... so I need to
   find small tasks that I can knock off the list.

   How do we do this?  Get a list of all tasks with =F12 t= and then narrow it down with filtering.
   To find leftover/orphaned (non-project, non-waiting, work) tasks on my list I do 
   =F12 t= to show all tasks then filter with =/w= to limit it to work tasks only, then
   =/-W= to remove waiting tasks and =/-P= to remove project tasks.

   That leaves me with about 30 tasks to look at and I can pick something that fits the minutes I have left before I 
   take off for lunch.
** Keeping the =STARTED= task list under control
   Some tasks are periodic.  Things I need to do weekly.
   Since I clock these tasks in they change to a =STARTED= state.
   Cyclic or repeated tasks automatically reschedule to the future and reset
   the task state back to =TODO= when they are marked =DONE=.  This removes it
   from the =STARTED= agenda view and helps keep the list short.  Tasks that 
   I've worked on but won't finish anytime soon can be removed from the =STARTED=
   agenda view simply by moving the task state keyword back to =TODO=.

* Time Clocking
  Okay, I admit it.  I'm a clocking fanatic.

  I clock everything (well almost everything).  Org-mode makes this
  really easy.  I'd rather clock too much stuff than not enough so I
  find it's easier to get in the habit of clocking everything.

  As an example of what I mean my clock data for April 20, 2009 shows
  14 hours 19 minutes of clocked time (which included 3 hours and 17
  minutes of painting my basement.)  My clocked day started at 6:57AM
  and ended at 23:11PM.  I have only a few holes in my clocked day
  (where I wasn't clocking anything):
 
  | Missing Clock Data |
  |--------------------|
  |        16:14-16:53 |
  |        16:55-17:19 |
  |        18:00-18:52 |

  This makes it possible to look back at the day and see where I'm
  spending too much time, or not enough time on specific projects.

  Without clocking data it's hard to tell what you did after the fact.

** Clock Setup
   I like to keep control of the clock separate from task state
   changes.  If I mark a clocked task =DONE= I want the clock to keep
   running on that task until I've finished all of the work on it.  I
   tend to mark tasks =DONE= just before I'm really finished with
   them.  This allows me to enter a note with the =DONE= state that
   may take a few minutes to compose and the time spent doing this
   counts towards clocking on that task.

   Keeping the clock running when moving a subtask to a =DONE= state
   means clocking continues to apply to the parent task.  I can pick
   the next task from the parent and clock that in without losing a
   minute or two while I'm deciding what to work on next.

   I have the following org-mode setup for clocking:

#+begin_src emacs-lisp
;;
;; Resume clocking tasks when emacs is restarted
(setq org-clock-persistence-insinuate)
;;
;; Yes it's long... but more is better ;)
(setq org-clock-history-length 35)
;; Resume clocking task on clock-in if the clock is open
(setq org-clock-in-resume t)
;; Change task state to STARTED when clocking in
(setq org-clock-in-switch-to-state "STARTED")
;; Save clock data and notes in the LOGBOOK drawer
(setq org-clock-into-drawer t)
;; Sometimes I change tasks I'm clocking quickly - this removes clocked tasks with 0:00 duration
(setq org-clock-out-remove-zero-time-clocks t)
;; Don't clock out when moving task to a done state
(setq org-clock-out-when-done nil)
;; Save the running clock and all clock history when exiting Emacs, load it on startup
(setq org-clock-persist t)
#+end_src
** Clocking in
  When I start or continue working on a task I clock it in with =C-c
  C-x C-i= (or just =I= in the agenda).  This changes the task state
  to =STARTED= and starts the clock for this task.

*** Setting a default clock task

    I have a default =* Organization= task in my norang.org file that
    I tend to put miscellaneous clock time on.  While reorganizing my
    org-files and doing other planning work that isn't for a specific
    project I'll clock in this task while I do things.  By clocking
    this task in with a double prefix =C-u C-u C-c C-x C-i= it starts
    the clock and makes this the default clock task.

    You can quickly clock in the default task with =C-u C-c C-x C-i d=
*** Using the clock history to clock in old tasks
    You can use the clock history to restart clocks on old tasks you've clocked or to jump
    directly to a task you have clocked previously.  I use this mainly to clock in whatever
    got interrupted by something.

    Consider the following scenario:

      - You are working on and clocking =Task A= (Organization)
      - You get interrupted and switch to =Task B= (Document my use of org-mode)
      - You complete =Task B= (Document my use of org-mode)
      - Now you want to go back to =Task A= (Organization) again to continue

    This is easy to deal with.  
    
    1. Clock in =Task A=, work on it
    2. Go to =Task B= (or create a new task) and clock it in
    3. When you are finished with =Task B= hit =C-u C-c C-x C-i i=

    This displays a clock history selection window like the following
    and selects the interrupted =[i]= entry.

*Clock history selection buffer for C-u C-c C-x C-i*
#+begin_example
Default Task
[d] norang          STARTED Organization                  <-- Task B
The task interrupted by starting the last one
[i] norang          STARTED Organization                  <-- Task B
Current Clocking Task
[c] org             STARTED Document my use of org-mode   <-- Task A
Recent Tasks
[1] org             STARTED Document my use of org-mode   <-- Task A
[2] norang          STARTED Organization                  <-- Task B
...
[Z] org             DONE Fix default section links        <-- 35 clock task entries ago
#+end_example
** Clock Everything - Create New Tasks
   In order to clock everything you need a task for everything.
   That's fine for planned projects but interruptions inevitably occur
   and you need some place to record whatever time you spend on that
   interruption.

   To deal with this we create a new remember task to record the thing
   we are about to do.  The workflow goes something like this:

   - You are clocking some task and an interruption occurs
   - Create a quick remember task =C-M-r=
   - Type the heading 
   - clock it in =C-c C-x C-i=
   - file it =C-c C-c=
   - Go do it
   - mark it =DONE=
   - clock something else in (return to the interrupted task with =C-u C-c C-x C-i i=)
   - refile the newly created and clocked task later

   This means you can ignore the details like where this task really
   belongs in your org file layout and just get on with completing the
   thing.  Refiling a bunch of tasks later in a group when it is
   convenient to refile the tasks saves time in the long run.
** Finding tasks to clock in
   To find a task to work on I use one of the following options
   (generally listed most frequently used first)

   - Use the clock history C-u C-c C-x C-i
     Go back to something I was clocking that is not finished
   - Pick something off today's agenda
     =SCHEDULED= or =DEADLINE= items that need to be done soon
   - Pick something off the =STARTED= tasks agenda view
     Work on some unfinished task to move to completion

   - Use an agenda view with filtering to pick something to work on
** Editing clock entries
   Sometimes it is necessary to edit clock entries so they reflect
   reality.  I find I do this for maybe 2-3 entries in a week.

   Occassionally I cannot clock in a task on time because I'm away
   from my computer.  In this case the previous clocked task is still
   running and counts time for both tasks which is wrong.

   I make a note of the time and then when I get back to my computer I
   clock in the right task and edit the start and end times to correct
   the clock history.

   To visit the clock line for an entry quickly use the agenda log
   mode.  =F12 a l= shows all clock lines for today.  I use this to
   navigate to the appropriate clock lines quickly.  F11 goes to the
   current clocked task but the agenda log mode is better for finding
   and visiting older clock entries.
   
   Use =F12 a l= to open the agenda in log mode and show only logged
   clock times.  Move the cursor down to the clock line you need to
   edit and hit =TAB= and you're there.

   To edit a clock entry just put the cursor on the part of the date
   you want to edit (use the keyboard not the mouse - since the
   clicking on the timestamp with the mouse goes back to the agenda
   for that day) and hit the =S-<up arrow>= or =S-<down arrow>= keys
   to change the time.

   The following setting makes time editing round to 5 minute
   increments:
#+begin_src emacs-lisp
(setq org-time-stamp-rounding-minutes (quote (1 5)))
#+end_src lisp

   Editing the time with the shift arrow combination also updates the
   total for the clock line which is a nice convenience.

   I always check that I haven't created task overlaps when fixing
   time clock entries by viewing them with log mode on in the agenda.

   I want my clock entries to be as accurate as possible but editing
   to the exact minute (instead of rounding to 5 minutes) takes more
   time and isn't worth the hassle.
* Time reporting and tracking
** Billing clients based on clocked time
   At the beginning of the month I invoice my clients for work done
   last month.  This is where I review my clocking data for 
   correctness before billing for the clocked time.

   Billing for clocked time basically boils down to the following
   steps:

   1. Verify that that clock data in complete and correct
   2. Use clock reports to summarize time spent
   3. Create an invoice based on the clock data

      I currently create invoices in an external software package
      based on the org-mode clock data.

   4. Archive complete tasks so they are out of the way.

      See [[*Archiving]] for more details.
*** Verify that clock data in complete and correct
   Since I change tasks often (sometimes more than once in a minute) I use the following setting
   to remove clock entries with a zero duration.
#+begin_src emacs-lisp
;; Sometimes I change tasks I'm clocking quickly - this removes clocked tasks with 0:00 duration
(setq org-clock-out-remove-zero-time-clocks t)
#+end_src

   This setting just keeps my clocked log entries clean - only
   keeping clock entries that contribute to the clock report.

   Before invoicing for clocked time it is important to make sure your
   clocked time data is correct.  If you have a clocked time with an
   entry that is not closed (ie. it has no end time) then that is a
   hole in your clocked day and it gets counted as zero (0) for time
   spent on the task when generating clock reports.  Counting it as
   zero is almost certainly wrong.

   To check for unclosed clock times I use the agenda-view log-mode
   (=l= in the agenda) with the following setup which shows clocked
   times only by default.  (To see all task state changes you can issue
   a prefix to this command (=C-u l= in the agenda)).

   To check the last month's clock data I use =F12 a m left-arrow l=
   which shows a full month in the agenda, moves to the previous
   month, and shows the clocked times only.

   The clocked-time only display in the agenda makes it easy to
   quickly scan down the list to see if an entry is missing an end
   time.  If an entry is not closed you can manually fix the clock
   entry based on other clock info around that time.

   Use the following setup to get log mode in the agenda to only show
   clocked times:
#+begin_src emacs-lisp
;; Agenda log mode items to display (clock time only by default)
(setq org-agenda-log-mode-items (quote (clock)))
#+end_src
*** Using clock reports to summarize time spent
   Billable time for clients are kept in separate org files.

   To get a report of time spent on tasks for =XYZ.org= you simply
   visit the =XYZ.org= file and run an agenda clock report for the
   last month with =F12 1 a m left-arrow R=.  This limits the agenda
   to this one file, shows the agenda for a full month, moves to last
   month, and generates a clock report.  Just scroll down to the end
   of the agenda to see the report.

   I export the agenda to a text file with =C-x C-w XYZ.txt= so I can
   cut and paste the report and save it as supporting information with
   the invoice.

   My agenda org clock report settings show 2 levels of detail and do
   not show links so that they are easier to cut and paste into other
   applications.
#+begin_src emacs-lisp
;; Agenda clock report parameters (no links, 2 levels deep)
(setq org-agenda-clockreport-parameter-plist (quote (:link nil :maxlevel 2)))
#+end_src

   I used to have a monthly clock report dynamic block in each project
   org file and manually updated them at the end of my billing cycle.
   I moved to using agenda clock reports shortly after that feature
   was added since I find this much more convenient.  The data isn't
   normally for consumption by anyone else so the format of the agenda
   clock report format is great for my use-case.

** Task Estimates and column view
   Estimating how long tasks take to complete is a difficult skill to
   master.  Org-mode makes it easy to practice creating estimates for
   tasks and then clock the actual time it takes to complete.

   By repeatedly estimating tasks and reviewing how your estimate
   relates to the actual time clocked you can tune your estimating
   skills.
*** Creating a task estimate with column mode
   I use =properties= and =column view= to do project estimates.

   I set up column view globally with the following headlines
#+begin_src emacs-lisp
; Set default column view headings: Task Effort Clock_Summary
(setq org-columns-default-format "%80ITEM(Task) %10Effort(Effort){:} %10CLOCKSUM")
#+end_src

   This makes column view show estimated task effort and clocked times
   side-by-side which is great for reviewing your project estimates.

   A property called =Effort= records the estimated amount of time
   a given task will take to complete.  The estimate times I use
   are one of:

   - 10 minutes
   - 30 minutes
   - 1 hour
   - 2 hours
   - 3 hours
   - 4 hours
   - 5 hours
   - 6 hours
   - 8 hours

   These are stored for easy use in =column mode= in the global property
   =Effort_ALL=.
#+begin_src emacs-lisp
; global Effort estimate values
(setq org-global-properties (quote (("Effort_ALL" . "0:10 0:30 1:00 2:00 3:00 4:00 5:00 6:00 8:00"))))
#+end_src

   To create an estimate for a task or subtree start column mode
   with =C-c C-x C-c= and collapse the tree with =c=.  This shows a
   table overlayed on top of the headlines with the task name, effort
   estimate, and clocked time in columns.

   With the cursor in the =Effort= column for a task you can easily
   set the estimated effort value with the quick keys =1= through =9=.

   After setting the effort values exit =column mode= with =q=.
   
*** Saving your estimate
    :PROPERTIES:
    :CUSTOM_ID: SavingEstimate
    :END:
    For fixed price jobs where you provide your estimate to a client,
    then work to complete the project it is useful to save the
    original estimate that is provided to the client.

    Save your original estimate by creating a dynamic clock report
    table at the top of your estimated project subtree.  Entering
    =C-c C-x i RET= inserts a clock table report with your estimated
    values and any clocked time to date.

#+begin_example 
Original Estimate
#+BEGIN: columnview :hlines 1 :id local
| Task                        | Estimated Effort | CLOCKSUM |
|-----------------------------+------------------+----------|
| ** TODO Project to estimate |             5:40 |          |
| *** TODO Step 1             |             0:10 |          |
| *** TODO Step 2             |             0:10 |          |
| *** TODO Step 3             |             5:10 |          |
| **** TODO Step 3.1          |             2:00 |          |
| **** TODO Step 3.2          |             3:00 |          |
| **** TODO Step 3.3          |             0:10 |          |
| *** TODO Step 4             |             0:10 |          |
#+END:
#+end_example

    I normally delete the =#+BEGIN:= and =#+END:= lines from the original
    table after providing the estimate to the client to ensure I don't
    accidentally update the table by hitting =C-c C-c= on the =#+BEGIN:= line.

    Saving the original estimate data makes it possible to refine the
    project tasks into subtasks as you work on the project without
    losing the original estimate data.
    
*** Reviewing your estimate
    =Column view= is great for reviewing your estimate.  This shows
    your estimated time value and the total clock time for the project
    side-by-side.

    Creating a dynamic clock table with =C-c C-x i RET= is a great
    way to save this project review if you need to make it available
    to other applications.

    =C-c C-x C-d= also provides a quick summary of clocked time for
    the current org file.
* Tags
  Tasks can have any number of arbitrary tags.  Tags are used for:

  - filtering todo lists and agenda views
  - providing context to some tasks
  - tagging notes
  - tagging phone calls
  - tagging NEXT actions for project tasks
  - tagging tasks in a WAITING state because a parent task is WAITING
  - preventing export of some subtrees when publishing

  Tags are mostly used for filtering in the agenda.  This means you
  can find tasks with a specific tag easily across your large number
  of org-mode files.

  Some tags are mutually exclusive.  These are defined in a group so
  that only one of the tags can be applied to a task at a time
  (disregarding tag inheritance).  I use these types for tags for
  applying context to a task.  (Work tasks have an =@Work= tag, and are
  done at the office, Farm tasks have an =@Farm= tag and are done at the
  farm -- I can't change the oil on the tractor if I'm not at the
  farm... so I hide these and other tasks by filtering my agenda view
  to only =@Work= tasks when I'm at the office.)

  Tasks are grouped together in org-files and a =#+FILETAGS:= entry
  applies a tag to all tasks in the file.  I use this to apply the
  =@Work= tag to projects that are Work related.

** Tags
   Here are my tag definitions with associated keys for filtering in
   the agenda views.

   The startgroup - endgroup (=@XXX=) tags are mutually exclusive -
   selecting one removes a similar tag already on the task.  These are
   the context tags - you can't be in two places at once so if a task
   is marked with @Farm and you add @Work then the @Farm tag is
   removed automagically.

   The other tags =QUOTE= .. =CANCELLED= are not mutually exclusive and
   multiple tags can appear on a single task.  Some of those tags are
   created by todo state change triggers.  The shortcut key is used to
   add or remove the tag using =C-c C-q= or to apply the task for
   filtering on the agenda.

#+begin_src emacs-lisp
; Tags with fast selection keys
(setq org-tag-alist (quote ((:startgroup)
			    ("@InTown" . ?t)
			    ("@Work" . ?w)
			    ("@Home" . ?h)
			    ("@Farm" . ?f)
			    (:endgroup)
			    ("QUOTE" . ?q)
			    ("NEXT" . ?N)
			    ("GSOC" . ?g)
			    ("PROJECT" . ?P)
			    ("WAITING" . ?W)
			    ("FARM" . ?F)
			    ("HOME" . ?H)
			    ("ORG" . ?O)
			    ("PLAY" . ?p)
			    ("CANCELLED" . ?C)))))

; Allow setting single tags without the menu
(setq org-fast-tag-selection-single-key (quote expert))

; For tag searches ignore tasks with scheduled and deadline dates
(setq org-agenda-tags-todo-honor-ignore-options t)
#+end_src

** Filetags
   Filetags are a convenient way to apply one or more tags to all of
   the headings in a file.

   Filetags look like this:

#+begin_example 
#+FILETAGS: NORANG @Work
#+end_example

   I have the following =#+FILETAGS:= entries in my org-mode files:

*** Non-work related org-mode files
| File         | Tags           |
|--------------+----------------|
| todo.org     | HOME           |
| gsoc2009.org | GSOC HOME PLAY |
| bzflag.org   | BZFLAG PLAY    |
| git.org      | GIT PLAY       |
| org.org      | ORG PLAY       |
| mark.org     | MARK           |
| farm.org     | FARM           |

*** Work related org-mode files
| File         | Tags           |
|--------------+----------------|
| norang.org   | NORANG @Work   |
| ABC.org      | ABC @Work      |
| XYZ.org      | XYZ @Work      |
| ABC-DEF.org  | ABC DEF @Work  |
| ABC-KKK.org  | ABC KKK @Work  |
| YYY.org      | YYY @Work      |

*** Refile tasks
| File         | Tags           |
|--------------+----------------|
| phone.org    | PHONE REFILE   |
| notes.org    | NOTES REFILE   |
| tasks.org    | REFILE         |
|--------------+----------------|

** Trigger Tags
   The following tags are automatically added or removed by todo state
   triggers described previously in [[*ToDo%20state%20triggers][*ToDo state triggers]]

   - =WAITING=
   - =CANCELLED=
   - =NEXT=
   - =PROJECT=
* Handling Notes
  Notes are little gems of knowledge that you come across during your
  day.  They are just like tasks except there is nothing to do (except
  learn and memorize the gem of knowledge).  Unfortunately there are
  way too many gems to remember and my head explodes just thinking
  about it.

  org-mode to the rescue!

  Often I'll find some cool feature or thing I want to remember while
  reading the org-mode and git mailing lists in Gnus.  To create a
  note I use my note remember template =C-M-r n=, type a heading for
  the note and =C-c C-c= to save it.  The only other thing to do is to
  refile it (later) to the appropriate project file.

  I have an agenda view just to find notes.  Notes are refiled to an
  appropriate project file and task.  If there is no specific task it
  belongs to it goes to the catchall =* Notes= task.  I generally have
  a catchall notes task in every project file.  Notes are created with
  a =NOTE= tag already applied by the remember template so I'm free to
  refile the note anywhere.  As long as the note is in a project file
  that contributes to my agenda (ie. in org-agenda-files) then I can
  find the note back easily with my notes agenda view by hitting the
  key combination =F12 n=.  I'm free to limit the agenda view of notes
  using standard agenda tag filtering.

  technical details without the need to actually remember anything -
  Short notes with a meaningful headline are a great way to remember
  other than how to find them back when you need them using =F12 n=.

  Notes that are project related and not generally useful can be
  archived with the project and removed from the agenda when the
  project is removed.

  So my org notes go in org.org and my git notes go in git.org both
  under the =* Notes= task.  I'll forever be able to find those.  A
  note about some work project detail I want to remember with the
  project is filed to the project task under the appropriate work
  org-mode file and eventually gets removed from the agenda when the
  project is complete and archived.
* GTD stuff
  Most of my day is deadline/schedule driven.
  I work off of the agenda first and then pick items from the todo lists as
  outlined in [[*What%20do%20I%20work%20on%20next][*What do I work on next]]

** Weekly Review Process
   The first day of the week (usually Monday) I do my weekly review. 
   I keep a list like this one to remind me what needs to be done.

   I have a recurring task which keeps my weekly review checklist
   handy.  This pops up as a reminder on Monday's.  This week I'm
   doing my weekly review on Tuesday since Monday was a holiday.

: ** STARTED Weekly Review [0/5]
:    SCHEDULED: <2009-05-18 Mon ++1w> 
:    :LOGBOOK:...
:    :PROPERTIES:...
: 
:    What to review:
: 
:     - [ ] Check follow-up folder
:     - [ ] Review new tasks                                  F12-r
:       - if it takes less than 5 minutes just do it
:       - otherwise assign an estimated time and file it somewhere
:       - Refile billable work to appropriate location
:     - [ ] Check for stuck projects and add next tasks       F12-#         
:     - [ ] Review all tasks F12 t
:       - [ ] Work tasks F12 t / w / - W
:       - [ ] Miscellaneous work tasks / - P / - W
:       - [ ] Projects F12 P
:       - [ ] Next Tasks F12 t / N / - W (Next tasks can not be blocked)
: 	- Move NEXT tag to subtasks or remove as required
:       - [ ] Waiting Tasks F12 t 4 r
:       - [ ] Someday Tasks F12 t 5 r
:     - [ ] Make plan for the week (out of NEXT tasks)

   The first item [ ] Check follow-up folder makes me pull out the
   paper file I dump stuff into all week long - things I need to take
   care of but are in no particular hurry to deal with.  Stuff I get
   in the mail etc that I don't want to deal with now.  I just toss it
   in my =Follow-Up= folder in the filing cabinet and forget about it
   until the weekly review.

   I go through the folder and weed out anything that needs to be
   dealt with.  After that everything else is in =org-mode=.  I tend
   to schedule tasks onto the agenda for the coming week so that I
   don't spend lots of time trying to find what needs to be worked on
   next.

   This works for me.  You're mileage may vary ;)
** UNFINISHED Project definition and finding stuck projects
#+begin_src emacs-lisp
(setq org-stuck-projects (quote ("/PROJECT" nil ("NEXT") "")))
#+end_src

* Archiving
** Archiving Subtrees
   My normal archiving procedure is to move entire subtrees to a
   separate archive file for the project.  Task subtrees in =FILE.org=
   get archived to =FILE.org_archive= using the =C-c C-x C-s= command.

   I archive entire projects and subtrees into a single
   forever-growing file.  My archive files are huge but so far I
   haven't found a need to split them by year (or decade) :)

** Archive Tag - Hiding Information
   The only time I set the ARCHIVE tag on a task is to prevent it from
   opening by default because it has tons of information I don't
   really need to look at on a regular basis.  I can open the task
   with C-TAB if I need to see the gory details (like a huge table of
   data related to the task) but normally I don't need that
   information displayed.
** When to Archive
   Archiving monthly works well for me.  I normally invoice clients on
   the first of the month and after using the time clock information
   for the previous month I archive any =DONE= tasks and projects.

   This keeps my main working files clutter-free.  If I never need the
   detail for the archived tasks they are available in the appropriate
   archive file.
* Publishing
  :PROPERTIES:
  :CUSTOM_ID: Publishing
  :END:

  I don't do a lot of publishing for other people but I do keep a set
  of private client system documentation online.  Most of this
  documentation is a collection of notes exported to HTML.

  Almost everything at http://doc.norang.ca/ is generated by
  publishing org-files.  The notable exception to that is the index
  page which is currently automatically generated from a Python script
  based on the HTML files that exist in the document directory.

  It is supposed to be possible to generate index files from org-mode
  but I've never spent the time to figure that out since I already
  have a working index page in place.

  Org-mode can export to a variety of publishing formats including (but not limited to)

  - ASCII
    (plain text - but not the original org-mode file)
  - HTML 
  - LaTex
  - Docbook
    which enables getting to lots of other formats like ODF, XML, etc
  - PDF
    via LaTex or Docbook
  - iCal

  I haven't begun the scratch the surface of what org-mode is capable
  of doing.  My main use case for org-mode publishing is just to
  create HTML documents for viewing online conveniently.  Someday I'll
  get time to try out the other formats when I need them for
  something.

** Playing with ditaa

[[http://ditaa.sourceforge.net/][ditaa]] is a great tool for quickly generating graphics to convey ideas
and =ditaa= is included with org-mode!  Some of the graphics in this document
are automatically generated by org-mode and ditaa from plain text
source.

The following graphic is one example of what you can do easily with
ditaa:

This

: #+begin_ditaa communication.png -r -s 0.8 
:      +-----------+        +---------+   
:      |    PLC    |        |         |                 
:      |  Network  +<------>+   PLC   +<---=---------+  
:      |    cRED   |        |  c707   |              |  
:      +-----------+        +----+----+              |  
:                                ^                   |  
:                                |                   |  
:                                |  +----------------|-----------------+ 
:                                |  |                |                 | 
:                                v  v                v                 v 
:        +----------+       +----+--+--+      +-------+---+      +-----+-----+       Windows clients 
:        |          |       |          |      |           |      |           |      +----+      +----+ 
:        | Database +<----->+  Shared  +<---->+ Executive +<-=-->+ Operator  +<---->|cYEL| . . .|cYEL| 
:        |   c707   |       |  Memory  |      |   c707    |      | Server    |      |    |      |    | 
:        +--+----+--+       |{d} cGRE  |      +------+----+      |   c707    |      +----+      +----+ 
:           ^    ^          +----------+             ^           +-------+---+ 
:           |    |                                   |                         
:           |    +--------=--------------------------+                     
:           v                                                              
:  +--------+--------+                                                          
:  |                 |                                                          
:  | Millwide System |            -------- Data ---------                       
:  | cBLU            |            --=----- Signals ---=--                       
:  +-----------------+                                                         
: #+end_ditaa

becomes this!

#+begin_ditaa communication.png -r -s 0.8
:      +-----------+        +---------+  
:      |    PLC    |        |         |                
:      |  Network  +<------>+   PLC   +<---=---------+ 
:      |    cRED   |        |  c707   |              | 
:      +-----------+        +----+----+              | 
:                                ^                   | 
:                                |                   | 
:                                |  +----------------|-----------------+
:                                |  |                |                 |
:                                v  v                v                 v
:        +----------+       +----+--+--+      +-------+---+      +-----+-----+       Windows clients
:        |          |       |          |      |           |      |           |      +----+      +----+
:        | Database +<----->+  Shared  +<---->+ Executive +<-=-->+ Operator  +<---->|cYEL| . . .|cYEL|
:        |   c707   |       |  Memory  |      |   c707    |      | Server    |      |    |      |    |
:        +--+----+--+       |{d} cGRE  |      +------+----+      |   c707    |      +----+      +----+
:           ^    ^          +----------+             ^           +-------+---+
:           |    |                                   |                        
:           |    +--------=--------------------------+                    
:           v                                                             
:  +--------+--------+                                                         
:  |                 |                                                         
:  | Millwide System |            -------- Data ---------                      
:  | cBLU            |            --=----- Signals ---=--                      
:  +-----------------+                                                         
#+end_ditaa

#+begin_src emacs-lisp
(load "~/git/org-mode/contrib/lisp/org-exp-blocks")
(setq org-ditaa-jar-path "~/java/ditaa0_6b.jar")
#+end_src
** Playing with graphviz
[[http://www.graphviz.org/][Graphviz]] is another great tool for creating graphics in your documents.

This

: #+begin_dot gv01.png -Kdot -Tpng
: digraph G {
:   concentrate=true;
:   subgraph cluster_wrapline {
:     label="Wrapline Control System";
:     color=purple;
:     sharedmem [style=filled, fillcolor=lightgrey, shape=box];
:     sharedmem -> exec [style=dotted];
:     sharedmem -> db [style=dotted];
:     sharedmem -> plc [style=dotted];
:     sharedmem -> opserver [style=dotted];
:     exec -> db;
:     exec -> opserver;
:     plc -> exec;
:   };
:   plcnet [shape=box, label="PLC Network"];
:   plcnet -> plc;
:   millwide [shape=box, label="Millwide System"];
:   db -> millwide;
: 
:   subgraph cluster_opclients {
:     color=blue;
:     client1[label="client"];
:     client2[label="client"];
:     client3[label="client"];
:     clientn[label="client"];
:     opserver -> client1;
:     opserver -> client2;
:     opserver -> client3;
:     opserver -> clientn;
:   };
: };
: #+end_dot

becomes this!

#+begin_dot gv01.png -Kdot -Tpng
digraph G {
  concentrate=true;
  subgraph cluster_wrapline {
    label="Wrapline Control System";
    color=purple;
    sharedmem [style=filled, fillcolor=lightgrey, shape=box];
    sharedmem -> exec [style=dotted];
    sharedmem -> db [style=dotted];
    sharedmem -> plc [style=dotted];
    sharedmem -> opserver [style=dotted];
    exec -> db;
    exec -> opserver;
    plc -> exec;
  };
  plcnet [shape=box, label="PLC Network"];
  plcnet -> plc;
  millwide [shape=box, label="Millwide System"];
  db -> millwide;

  subgraph cluster_opclients {
    color=blue;
    client1[label="client"];
    client2[label="client"];
    client3[label="client"];
    clientn[label="client"];
    opserver -> client1;
    opserver -> client2;
    opserver -> client3;
    opserver -> clientn;
  };
};
#+end_dot

The =-Kdot= is optional (defaults to =dot=) but you can substitute other graphviz
types instead here (ie. =twopi=, =neato=, =circo=, etc).

** Publishing Single Files
   Org-mode exports the current file to one of the standard formats by
   invoking an export function.  The standard key binding for this is
   =C-c C-e= followed by the key for the type of export you want.

   This works great for single files or parts of files -- if you
   narrow the buffer to only part of the org-mode file then you only
   get the narrowed detail in the export.

** Publishing Projects

   I mainly use publishing for publishing multiple files or projects.
   I don't want to remember where the created export file needs to
   move to and org-mode projects are a great solution to this.

   The [[http://doc.norang.ca]] website (and a bunch of other files that
   are not publicly available) are all created by editing org-mode
   files and publishing the project the file is contained in.  This is
   great for people like me who want to figure out the details once
   and forget about it.  I love stuff that Just Works(tm).

   I have 3 main projects I use org-mode publishing for currently:

   - norang (website)
   - doc.norang.ca (website)
   - org files (which are selectively included by other websites)

   Here's my publishing setup:

#+begin_src emacs-lisp
; experimenting with docbook exports - not finished
(setq org-export-docbook-xsl-fo-proc-command "fop %s %s")
(setq org-export-docbook-xslt-proc-command "xsltproc --output %s /usr/share/xml/docbook/stylesheet/nwalsh/fo/docbook.xsl %s")
;
; Inline images in HTML instead of producting links to the image
(setq org-export-html-inline-images t)
; Do not use sub or superscripts - I currently don't need this functionality in my documents
(setq org-export-with-sub-superscripts nil)

; List of projects
; norang - http://www.norang.ca/
; doc    - http://doc.norang.ca/
; org    - miscellaneous todo lists for publishing
(setq org-publish-project-alist
;
; http://www.norang.ca/  (norang website)
; norang-org are the org-files that generate the content
; norang-extra are images and css files that need to be included
; norang is the top-level project that gets published
      (quote (("norang-org"
	       :base-directory "~/git/www.norang.ca"
	       :publishing-directory "/ssh:www-data@www:~/www.norang.ca/htdocs"
	       :recursive t
	       :section_numbers nil
	       :table-of-contents nil
	       :base-extension "org"
	       :publishing-function org-publish-org-to-html
	       :style-include-default nil
	       :section-numbers nil
	       :table-of-contents nil
	       :style-include-default nil
	       :style "<link rel=\"stylesheet\" href=\"norang.css\" type=\"text/css\">"
	       :author-info nil
	       :creator-info nil)
	      ("norang-extra"
	       :base-directory "~/git/www.norang.ca/"
	       :publishing-directory "/ssh:www-data@www:~/www.norang.ca/htdocs"
	       :base-extension "css\\|pdf\\|png\\|jpg\\|gif"
	       :publishing-function org-publish-attachment
	       :recursive t
	       :author nil)
	      ("norang"
	       :components ("norang-org" "norang-extra"))
;
; http://doc.norang.ca/  (norang website)
; doc-org are the org-files that generate the content
; doc-extra are images and css files that need to be included
; doc is the top-level project that gets published
	      ("doc-org"
	       :base-directory "~/git/doc.norang.ca/"
	       :publishing-directory "/ssh:www-data@www:~/doc.norang.ca/htdocs"
	       :recursive t
	       :section_numbers nil
	       :table-of-contents nil
	       :base-extension "org"
	       :publishing-function (org-publish-org-to-html org-publish-org-to-org)
	       :plain-source t
	       :htmlized-source t
	       :style-include-default nil
	       :style "<link rel=\"stylesheet\" href=\"/org.css\" type=\"text/css\">"
	       :author-info nil
	       :creator-info nil)
	      ("doc-extra"
	       :base-directory "~/git/doc.norang.ca/"
	       :publishing-directory "/ssh:www-data@www:~/doc.norang.ca/htdocs"
	       :base-extension "css\\|pdf\\|png\\|jpg\\|gif"
	       :publishing-function org-publish-attachment
	       :recursive t
	       :author nil)
	      ("doc"
	       :components ("doc-org" "doc-extra"))
;
; Miscellaneous pages for other websites
; org are the org-files that generate the content
	      ("org"
	       :base-directory "~/git/org/"
	       :publishing-directory "/ssh:www-data@www:~/org"
	       :recursive t
	       :section_numbers nil
	       :table-of-contents nil
	       :base-extension "org"
	       :publishing-function org-publish-org-to-html
	       :style-include-default nil
	       :style "<link rel=\"stylesheet\" href=\"/org.css\" type=\"text/css\">"
	       :author-info nil
	       :creator-info nil))))

; I'm lazy and don't want to remember the name of the project to publish when I modify 
; a file that is part of a project.  So this function saves the file, and publishes
; the project that includes this file
;
; It's bound to C-S-F12 so I just edit and hit C-S-F12 when I'm done and move on to the next thing
(defun my-save-then-publish ()
  (interactive)
  (save-buffer)
  (org-save-all-org-buffers)
  (org-publish-current-project))

(global-set-key (kbd "C-s-<f12>") 'my-save-then-publish)
#+end_src

   The =norang= and =doc= projects publish directly into the webserver
   directory that serves that site.  Publishing one of these projects
   exports all modified pages, generates images with ditaa, copies the
   resulting files to the webserver so that they are immediately
   available for viewing.

   The http://doc.norang.ca/ site contains subdirectories with client
   documentation that are restricted access using Apache Basic
   authentication and I don't create links to these sites from the
   publicly viewable pages.  http://doc.norang.ca/someclient/ would
   show the index for any org files under
   =~/git/doc.norang.ca/someclient/= if that is set up as a viewable
   website.  I use most of the information myself but give access to
   clients if they are interested in the information/notes that I keep
   about their systems.

   This works great for me - I know where my notes are and I can
   access them from anywhere on the internet.  I'm also free to share
   notes with other people by simply giving them the link to the
   appropriate site.

   All I need to remember to do is edit the appropriate org file and
   publish it with C-S-F12 -- not exactly hard :)


* Reminders
  I use appt for reminders.  It's simple and unobtrusive -- putting
  pending appointments in the status bar and beeping as 12, 9, 6, 3,
  and 0 minutes before the appointment is due.

  Everytime the agenda is displayed (and that's lots for me) the
  appointment list is erased and rebuilt from the current agenda
  details for today.  This means everytime I reschedule something, add
  or remove tasks that are time related the appointment list is
  automatically updated the next time I look at the agenda.
  
** Reminder Setup
#+begin_src emacs-lisp
; Erase all reminders and rebuilt reminders for today from the agenda
(defun my-org-agenda-to-appt ()
  (interactive)
  (setq appt-time-msg-list nil)
  (org-agenda-to-appt))

; Rebuild the reminders everytime the agenda is displayed
(add-hook 'org-finalize-agenda-hook 'my-org-agenda-to-appt)

; This is at the end of my .emacs - so appointments are set up when Emacs starts
(my-org-agenda-to-appt)

; Activate appointments so we get notifications
(appt-activate t)

; If we leave Emacs running overnight - reset the appointments one minute after midnight
(run-at-time "24:01" nil 'my-org-agenda-to-appt)
#+end_src
* Productivity Tools
  :PROPERTIES:
  :CUSTOM_ID: ProductivityTools
  :NOBLOCKING: t
  :END:
  This section is a miscellaneous collection of Emacs customizations that I use
  with org-mode so that it Works-For-Me(tm).
** Yasnippets
   Yasnippets is cool!  You type the snippet name and =TAB= and
   yasnippet expands the name with the contents of the snippet text -
   substituting snippet variables as appropriate.

   Yasnippet comes with lots of snippets for programming languages.
   So far I only use 1 snippet (=block=) for =org-mode=.

   Setup =yasnippet= with the following code in your =.emacs=
#+begin_src emacs-lisp
(require 'yasnippet)
(yas/initialize)
(yas/load-directory "~/.emacs.d/plugins/yasnippet/snippets")

;; Make TAB the yas trigger key in the org-mode-hook and turn on flyspell mode
(add-hook 'org-mode-hook
	  (lambda ()
	    ;; yasnippet
	    (make-variable-buffer-local 'yas/trigger-key)
	    (setq yas/trigger-key [tab])
	    (define-key yas/keymap [tab] 'yas/next-field-group)
	    ;; flyspell mode to spell checking everywhere
	    (flyspell-mode 1)))
#+end_src

   Here is the definition for the =block= snippet:

org-mode Yasnippet: ~/.emacs.d/plugins/yasnippet/snippets/text-mode/org-mode/block
#+begin_example 
#name : #+begin_...#+end_
# --
#+begin_$1 $2
$0
#+end_$1
#+end_example

   I use this to create =#+begin_*= blocks like 
     - =#+begin_example=
     - =#+begin_ditaa=
     - =#+begin_dot=
     - =#+begin_src=
     - etc.

   Simply type =block= then =TAB= and it replaces the =block= text
   with the snippet contents.  Then type =src TAB emacs-lisp TAB= and
   your snippet block is done.

   Hit =C-c SingeQuote(')= and insert whatever emacs-lisp code you
   need.  While in this block you're in a mode that knows how to
   format and colourize emacs lisp code as you enter it which is
   really nice.  =C-c SingleQuote(')= exits back to org-mode.  This
   recognizes any emacs editing mode so all you have to do is enter
   the appropriate mode name for the block.

   This is a great time saver.
** Limit your view to what you are working on
   :PROPERTIES:
   :CUSTOM_ID: LimitingAgendaView
   :END:
   There is more than one way to do this.  Use what works for you.
*** Narrowing to a subtree with =my-org-todo=
=f5= is bound the function =my-org-todo= which is defined as follows:

#+begin_src emacs-lisp
(global-set-key (kbd "<f5>") 'my-org-todo)

(defun my-org-todo ()
  (interactive)
  (org-narrow-to-subtree)
  (org-show-todo-tree nil)
  (widen))
#+end_src

This makes it easy to hide all of the other details in your org-file
temporarily by limiting your view to this task subtree.  Tasks are
folded and hilighted so that only tasks which are incomplete are
shown.

I hit =f5= a lot.  This basically does a =org-narrow-to-subtree= and =C-c C-v= combination
leaving the buffer in a narrowed state.  I use =S-f5= to widen back to the normal view.
*** Limiting the agenda to a subtree
    =C-c C-x <= turns on the agenda restriction lock for the current subtree.
    This keeps your agenda focused on only this subtree.  Alarms and notifications are still
    active outside the agenda restriction.  =C-c C-x >= turns off the agenda restriction
    lock returning your agenda view back to normal.

    I don't normally use the agenda restriction lock.  I normally want
    to see all =work= tasks which are in multiple files so agenda view
    filtering works better for me.
*** Limiting the agenda to a file
    You can limit the agenda view to a single file in multiple ways.

    You can use the agenda restriction lock =C-c C-x <= on the any
    line before the first heading to set the agenda restriction lock
    to this file only.  This lock stays in effect until you remove it
    with =C-c C-x C-r=.

    Another way is to invoke the agenda with =F12 1 a= while visiting
    an org-mode file.  This limits the agenda view to just this file.
    I occassionally use this to view a file not in my
    =org-agenda-files= in the agenda.

** Tuning the Agenda Views
   Various customizations affect how the agenda views show task
   details.  This section shows each of the customizations I use in my
   workflow.
*** Highlight the current agenda line
    The following code in my =.emacs= file keeps the current agenda
    line highlighted.  This makes it obvious what task will be
    affected by commands issued in the agenda.  No more acting on the
    wrong task by mistake!

#+begin_src emacs-lisp
;; Always hilight the current agenda line
(add-hook 'org-agenda-mode-hook '(lambda () (hl-line-mode 1)))
#+end_src

*** Remove tasks with dates from the global todo lists
    Tasks with dates (=SCHEDULED:=, =DEADLINE:=, or active dates) show
    up in the agenda when appropriate.  Use the following settings to
    remove these tasks from the global todo lists.  The idea here is
    the agenda has date-related items and the global todo lists have
    everything else.  Keeping tasks only one list only prevents having
    to review tasks more than once when browsing the lists.

    Tasks with dates are scheduled into the future sometime and you
    don't need to deal with them until the date approaches.
#+begin_src emacs-lisp
;; Keep tasks with dates off the global todo lists
(setq org-agenda-todo-ignore-with-date t)

;; Remove completed deadline tasks from the agenda view
(setq org-agenda-skip-deadline-if-done t)

;; Remove completed scheduled tasks from the agenda view
(setq org-agenda-skip-scheduled-if-done t)
#+end_src

*** Use the Diary for Holidays only
    I don't use the emacs Diary for anything but I like seeing the
    holidays on my agenda.  This helps with planning for those days
    when you're not supposed to be working.

#+begin_src emacs-lisp
(setq org-agenda-include-diary nil)
#+end_src

    I don't have a =~/diary= file anymore.

    I include holidays from the calendar in my =todo.org= file as follows:
: #+FILETAGS: HOME
: * Appointments
:   :PROPERTIES:
:   :CATEGORY: Appt
:   :ARCHIVE:  %s_archive::* Appointments
:   :END:      
: ** Holidays
:    :PROPERTIES:
:    :Category: Holiday
:    :END:
: ...

*** Searches include archive files
    I keep a single archive file for each of my org-mode project files.
    This allows me to search the current file and the archive when I need to
    dig up old information from the archives.

    I don't need this often but it sure it handy on the occasions that
    I do need it.

#+begin_src emacs-lisp
;; Include agenda archive files when searching for things
(setq org-agenda-text-search-extra-files (quote (agenda-archives)))
#+end_src
*** Agenda view tweaks
    The following agenda customizations control 
    - display of repeating tasks

    - display of empty dates on the agenda
    - task sort order
    - start the agenda display with today

      for the weekly view
    - display of the grid

Here are the =.emacs= settings:
#+begin_src emacs-lisp
;; Show all future entries for repeating tasks
(setq org-agenda-repeating-timestamp-show-all t)

;; Show all agenda dates - even if they are empty
(setq org-agenda-show-all-dates t)

;; Sorting order for tasks on the agenda
(setq org-agenda-sorting-strategy
      (quote ((agenda time-up priority-down effort-up category-up)
	      (todo priority-down)
	      (tags priority-down))))

;; Start the weekly agenda today
(setq org-agenda-start-on-weekday nil)

;; Disable display of the time grid
(setq org-agenda-time-grid
      (quote (nil "----------------"
		  (800 1000 1200 1400 1600 1800 2000))))
#+end_src

** Checklist handling
   Checklists are great for repeated tasks with lots of things that need to be done.
   For a long time I was manually resetting the check boxes to unchecked when marking
   the repeated task =DONE= but no more!  There's a contributed =org-checklist= that
   can uncheck the boxes automagically when the task is marked done.

   Add the following to your =.emacs=
#+begin_src emacs-lisp
(load "~/git/org-mode/contrib/lisp/org-checklist")
#+end_src

   and then to use it in a task you simply set the property =RESET_CHECK_BOXES= to =t= 
   like this

: ** TODO Invoicing and Archive Tasks [0/7]
:    DEADLINE: <2009-07-01 Wed +1m -0d> 
:    :PROPERTIES:
:    :RESET_CHECK_BOXES: t
:    :END:
: 
:    - [ ] Do task 1
:    - [ ] Do task 2
:    ...
:    - [ ] Do task 7

** No Emacs backup files
   This isn't strictly an org-mode customization.

   I don't use Emacs backup files at all.  I find the =*~= files
   that litter my hard drive rather annoying actually so I turn
   them off with the following customization:

   #+begin_src emacs-lisp
   (setq backup-inhibited t)
   #+end_src

   The main reason I turn off backups is that I have a few encrypted
   files on my system that I occassionally decrypt, edit with Emacs, 
   and encrypt again.  After encrypting I delete the plain-text version 
   of the file.  I always forget to delete the Emacs backup file... and
   this leaves the plain-text version of the file on disk which is 
   unacceptable.  My solution is no more Emacs backup files.

   org-mode can also encrypt entries but I've never looked into that
   yet.  This may be a good alternative for some of my existing
   encrypted file work flows but I haven't had the time to explore it.
   Emacs and org-mode is an adventure!

** Backups
   =Backups that you have to work hard at don't get gone=.

   I lost a bunch of data over 10 years ago due to not having a
   working backup solution.  At the time I said =I'm not going to lose
   any important data ever again=.  So far so good :)

   My backups get done religiously.  What does this have to do with
   org-mode?  Not much really, other than I don't spend time doing
   backups -- they just happen -- which saves me time for other more
   interesting things.

   My backup philosophy is to make it possible to recover your data --
   not necessarily easy.  It doesn't have to be easy/fast to do the
   recovery because I'll rarely have to recover data from the backups.
   Saving time for recovery doesn't make sense to me.  I want the
   backup to be fast and painless since I do those all the time.

   I set up an automated network backup over 10 years ago that is
   still serving me well today.  All of my systems gets daily backups
   to a network drive.  These are collected weekly and written to DVD
   ISO images in case my machines walk off someday.

   Once a week I get an email that says 'These ISO images are ready to
   be burned to disk' and all I have to do is write them out.  Backups
   take minimal effort currently and I'm really happy about that.

   Since then =git= came into my life, so backups of =git=
   repositories that are on multiple machines is much less critical
   than it used to be.  There is an automatic backup of everything
   pushed to the remote repository.

** UNFINISHED Handling blocked tasks
Handling blocked tasks and the =NOBLOCKING= property (usually on repeated tasks)
#+begin_src emacs-lisp
(setq org-enforce-todo-dependencies t)
#+end_src
** UNFINISHED Task structure and presentation
I don't hide leading stars - I want to see the heading levels explicitly. 
I find myself typing ' *' when adding a new heading and then the font lock shows I messed up and created a list instead.
#+begin_src emacs-lisp 
(setq org-hide-leading-stars nil)
#+end_src emacs-lisp

I've converted my files between odd-levels-only and odd-even using the
functions =org-convert-to-odd-levels= and =org-convert-to-oddeven-levels= functions
a number of times.  I ended up going back to odd-even levels to reduce the amount of
leading whitespace on tasks.  I didn't find that lining up the headlines and tasks
in odd-levels-only to be all that helpful.
#+begin_src emacs-lisp
(setq org-odd-levels-only nil)
#+end_src

#+begin_src emacs-lisp
(setq org-blank-before-new-entry (quote ((heading)
					 (plain-list-item))))
(setq org-insert-heading-respect-content t)
(setq org-return-follows-link nil)
(setq org-reverse-note-order nil)
(setq org-show-following-heading t)
(setq org-show-hierarchy-above t)
(setq org-show-siblings nil)
(setq org-special-ctrl-a/e t)
(setq org-special-ctrl-k t)
(setq org-yank-adjusted-subtrees t)
(setq org-cycle-include-plain-lists nil)
(setq org-cycle-separator-lines 0)
#+end_src

** UNFINISHED Attachments
#+begin_src emacs-lisp
(setq org-id-method (quote uuidgen))
#+end_src

** UNFINISHED Deadlines and Agenda Visibility
#+begin_src emacs-lisp
(setq org-deadline-warning-days 30)
#+end_src

** UNFINISHED Exporting Tables to CVS
#+begin_src emacs-lisp
(setq org-table-export-default-format "orgtbl-to-csv")
#+end_src lisp
** UNFINISHED Visiting links
#+begin_src emacs-lisp
(setq org-link-frame-setup (quote ((vm . vm-visit-folder-other-frame)
				   (gnus . gnus-other-frame)
				   (file . find-file-other-window))))
#+end_src
** Logging stuff
   Most of my logging is controlled by the global =org-todo-keywords=

   My logging settings are set as follows:
#+begin_src emacs-lisp
(setq org-log-done (quote time))
(setq org-log-into-drawer nil)
#+end_src

   With =org-todo-keywords= set as 

#+begin_src emacs-lisp
(setq org-todo-keywords (quote ((sequence "TODO(t)" "STARTED(s)" "|" "DONE(d!/!)")
 (sequence "WAITING(w@/!)" "SOMEDAY(S!)" "PROJECT(P@)" "OPEN(O@") "|" "CANCELLED(c@/!)")
 (sequence "QUOTE(q!)" "QUOTED(Q!)" "|" "APPROVED(A@)" "EXPIRED(E@)" "REJECTED(R@)"))))
#+end_src

   This adds a log entry whenever a task moves to any of the following states:
   - to or out of =DONE= status
   - to =WAITING= status (with a note) or out of =WAITING= status
   - to =SOMEDAY= status
   - to =CANCELLED= status (with a note) or out of =CANCELLED= status
   - to =QUOTE= status
   - to =QUOTED= status
   - to =APPROVED= status (with a note)
   - to =EXPIRED= status (with a note)
   - to =REJECTED= status (with a note)
   - to =OPEN= status
   - to =PROJECT= status (with a note)

   I keep clock times in the =LOGBOOK= drawer but state change notes outside
   so unfolding the task shows *why* the task changed state - without the need
   to show the contents of the =LOGBOOK= drawer.
** UNFINISHED Limiting time spent on tasks
   Task estimates and =org-clock-sound=
   clock mode line property usage

* Things I Don't Use
  This is a partial list of things I know about but do not use.
  =org-mode= is huge with tons of features.  There are features out there
  that I don't know about yet or haven't explored so this list is not
  going to be complete.
** Task Priorities
   I use the agenda to figure out what to do work on next.  I don't
   use priorities at all.  I've played with them in the past and
   always go back to using no priorities.

   If I could find a good way to disable the keys that set priorities
   I would :).  Every so often I accidentally set a priority on a task
   and then need to remove it again.

#+begin_src emacs-lisp
(setq org-default-priority ?G)
(setq org-lowest-priority ?G)
#+end_src emacs-lisp

** Archive Sibling
   This was a cute idea but I find archiving entire complete subtrees better.  I don't mind
   having a bunch of tasks marked =DONE= (but not archived)
   
* Using Git for Automatic History, Backups, and Synchronization
  Editing folded regions of your org-mode file can be hazardous to
  your data.  My method for dealing with this is to put my org files
  in a =Git= source repository.
  
  My setup saves all of my org-files every hour and creates a commit
  with my changes automatically.  This lets me go back in time and
  view the state of my org files for any given hour over the lifetime
  of the document.  I've used this once or twice to recover data I
  accidentally removed while editing folded regions.

** Automatic Hourly Commits

   My Emacs setup saves all org buffers at 1 minute before the hour using the following code in my =.emacs=

#+begin_src emacs-lisp
(run-at-time "00:59" 3600 'org-save-all-org-buffers)
#+end_src

   A =cron= job runs at the top of the hour to commit any changes just
   saved by the call to =org-save-all-org-buffers= above.  I use a
   script to create the commits so that I can run it on demand to
   easily commit all modified work when moving from one machine to another.

   =crontab= details:
#+begin_example 
0 * * * * ~/bin/org-git-sync.sh >/dev/null
#+end_example

*** ~/bin/org-git-sync.sh
    Here is the shell script I use to create a =git= commit for each of my org-repositories.
    This loops through multiple repositories and commits any modified files.
    I have the following org-mode repositories:

    - org 

      for all of my organization project files and todo lists

    - doc-norang.ca

      for any changes to documents under http://doc.norang.ca/

    - www.norang.ca

      for any changes to my other website http://www.norang.ca/

This script does not create empty commits - =git= only creates a commit
if something was modified.
#+begin_src sh
#!/bin/sh
# Add org file changes to the repository
REPOS="org doc.norang.ca www.norang.ca"

for REPO in $REPOS
do
    echo "Repository: $REPO"
    cd ~/git/$REPO
    # Remove deleted files
    git ls-files --deleted -z | xargs -0 git rm >/dev/null 2>&1
    # Add new files
    git add . >/dev/null 2>&1
    git commit -m "$(date)"
done
#+end_src sh

I use the following =.gitignore= file in my org-mode =git=
repositories to keep export generated files out of my =git=
repositories.  If I include a graphic from some other source than
ditaa or graphviz then I'll add it to the repository manually.  By
default all PNG graphic files are ignored (since I assume they are
produced by ditaa during export)
#+begin_example 
core
core.*
*.html
*~
.#*
\#*\#
*.txt
*.tex
*.aux
*.dvi
*.log
*.out
*.ics
*.pdf
*.xml
*.org-source
*.png
*.toc
#+end_example
** Git - Edit files with confidence
   I use =git= in all of my directories where editing a file should be
   tracked.

   This means I can edit files with confidence.  I'm free to change
   stuff and break things because it won't matter.  It's easy to go
   back to a previous working version or to see exactly what changed
   since the last commit.  This is great when editing configuration
   files (such as apache webserver, bind9 DNS configurations, etc.)

   I find this extremely useful where your edits might break things
   and having =git= tracking the changes means if you break it you can
   just go back to the previous working version easily.  This is also
   true for package upgrades for software where the upgrade modifies
   the configuration files.

   I have every version of my edits in a local =git= repository.

** USB Stick synchronization
   So I recently acquired a Eee PC 1000 HE which now serves as my main
   road-warrior laptop replacing my 6 year old Toshiba Tecra S1.

   I have a server on my LAN that hosts bare git repositories for all
   of my projects.  The problem I was facing is I have to leave in 5
   minutes and want to make sure I have up-to-date copies of
   everything I work on when I take it on the road (without Internet
   access).

   To solve this I use a USB stick with bare git repositories on it.
   This includes my org-mode repositories as well as any other git
   repositories I'm interested in.
   
   Just before I leave I mount my USB stick on my workstation and run
   =usb-git-fetch= then =usb-git-push=.  For any repositories that
   give errors due to non-fast-forward merges I manually merge as
   required and rerun =usb-git-push= until it reports no errors.  This
   normally takes a minute to two to do.  Then I grab my Eee PC and my
   USB stick and leave.

   Later I mount my USB stick in the Eee PC and do =usb-git-fetch= to
   grab all of the commits from my workstation.  I can merge as
   required for whatever I want to work on when I'm on the road
   knowing I have full up-to-date history of all my git repos on the
   USB stick.

   This really works great!  The problem I had with using a local lan
   bare repo was I'd forget to push/fetch a few repostories - always
   the ones I actually wanted to use when offline.  Using the USB
   stick guarantees that all repositories are up to date and allows me
   to be completely mobile and not dependent on Internet access.

   I mount my USB stick in a directory =/usb= using the =fstab= entry as follows:
: /dev/sdb1 /usb vfat defaults,user,noauto,shortname=mixed 0 0

   The 3 scripts I use do the following:

   | Script          | Description                                                               |
   |-----------------+---------------------------------------------------------------------------|
   | usb-git-fetch   | For each repo on the USB stick fetch from it if it exists on this machine |
   | usb-git-push    | For each repo on the USB stick push to it if it exists on this machine    |
   | usb-git-missing | For each repo on the USB stick report if we don't have a local copy of it |

Here is the =usb-git-fetch= script
#+begin_src sh
#!/bin/sh
find /usb -type d -name '*.git' | sed 's@^/usb/@@; s/.git$//' | while read repo; do 
  if test -d ~/${repo/.git}
  then
    echo REPO: $repo
    cd ~/$repo
    git fetch usb
  fi
done
#+end_src

Here is the =usb-git-push= script
#+begin_src sh
#!/bin/sh
find /usb -type d -name '*.git' | sed 's@^/usb/@@; s/.git$//' | while read repo; do
  if test -d ~/${repo/.git}
  then
    echo REPO: $repo
    cd ~/$repo 
    git push usb
  fi
done
#+end_src

Here is the =usb-git-missing= script
#+begin_src sh
#!/bin/sh
find /usb -type d -name '*.git' | sed 's@^/usb/@@; s/.git$//' | while read repo; do 
  if ! test -d ~/${repo/.git}
  then
    echo REPO: $repo
  fi
done
#+end_src

* Other stuff we may not want to include 			   :noexport:
** UNFINISHED Handling Phone calls
   - Remember tasks for phone calls and bbdb searches

** UNFINISHED Recurring tasks and copy subtree
** UNFINISHED Notes are gone
  I have a default notes-file defined but the only time I really reference
  notes is from the agenda template.

#+begin_src emacs-lisp
(setq org-default-notes-file "~/git/org/notes.org")
#+end_src

  They go to refile.org now
